{% block head %}
<style>
    html, body {
        height: 100%;
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
    }

    body {
        display: flex;
        align-items: flex-start;
        justify-content: center;
        flex-direction: column;
    }

    #svg-container {
        width: 100%;
        height: 600px;
        border: 1px solid #ccc;
        overflow: auto;
    }

    svg {
        width: 100%;
        height: 100%;
    }

    #raw-plan {
        max-height: 200px;
        overflow-y: auto;
        font-size: 12px;
    }
</style>
{% endblock %}

{% block content %}

<div id="svg-container">
    <svg id="svg"></svg>
</div>
{% endblock %}

{% block scripts %}
<script type="module">
    import * as d3 from "https://cdn.skypack.dev/d3@7.8.4";
    import * as d3dag from "https://cdn.skypack.dev/d3-dag@1.1.0";

    /**
     * Draws the Directed Acyclic Graph (DAG) for a specific query plan.
     * @param {Array} queryPlan - The raw query plan data from the server.
     */
function drawDag(queryPlan) {
    try {
        const planData = queryPlan?.find(([planType]) => planType === "serializedLogicalPlan")?.[1];

        if (!Array.isArray(planData) || planData.length === 0) {
            console.error("No valid serializedLogicalPlan data found:", planData);
            return;
        }

        // Map the query plan data into nodes.
        const dagNodes = planData.map(node => ({
            id: node.id?.toString(),
            parentIds: (node.inputs || []).map(input => input.toString()),
            label: node.label || "Unnamed Node",
            type: node.node_type || "Unknown",
        }));

        if (!dagNodes.every(node => node.id)) {
            throw new Error("One or more nodes are missing valid 'id' properties.");
        }

        // Clear the SVG content.
        const svg = d3.select("#svg");
        svg.selectAll("*").remove();

        // Build the DAG structure.
        const stratify = d3dag.graphStratify()
            .id(d => d.id)
            .parentIds(d => d.parentIds);

        const graph = stratify(dagNodes);

        // Apply layout using Sugiyama.
        const layout = d3dag.sugiyama()
            .nodeSize([120, 60]) // Node dimensions
            .coord(d3dag.coordCenter());
        const { width, height } = layout(graph);

        // Configure SVG container

        const padding_x = 300;
        const padding_y = 300;

        const svgContainer = svg
            .attr("viewBox", `0 0 ${width + padding_x} ${height + padding_y}`)
            .attr("preserveAspectRatio", "xMidYMid meet");
        // Create a container group for the graph.
        const container = svgContainer.append("g").attr("transform", "translate(150,150)");


        // Draw edges using Sugiyama-generated points.
        const line = d3.line().curve(d3.curveMonotoneY);
        container.append("g")
            .selectAll("path")
            .data(graph.links())
            .join("path")
            .attr("d", d => line(d.points))
            .attr("fill", "none")
            .attr("stroke", "#aaa")
            .attr("stroke-width", 2);

        // Draw nodes with rectangles (for labels).
        const nodeGroups = container.append("g")
            .selectAll("g")
            .data(graph.nodes())
            .join("g")
            .attr("transform", d => `translate(${d.x},${d.y})`);

        nodeGroups.each(function(d) {
            const g = d3.select(this);

            // Render text to measure dimensions for the rectangle.
            const text = g.append("text")
                .text(d => d.data.label)
                .attr("text-anchor", "middle") // Center text horizontally.
                .attr("font-size", 12)
                .attr("fill", "#000")
                .attr("dy", 4); // Slight vertical adjustment.

            // Measure text width for dynamic rectangle sizing.
            const textWidth = text.node().getBBox().width;
            const boxPadding = 10; // Box padding around the text.

            // Draw a rectangle behind the text.
            g.insert("rect", "text")
                .attr("x", -(textWidth / 2) - boxPadding / 2) // Center the rectangle horizontally.
                .attr("y", -15) // Align above the text vertically.
                .attr("width", textWidth + boxPadding)
                .attr("height", 30)
                .attr("fill", d => getNodeColor(d.data.type))
                .attr("stroke", "#000")
                .attr("stroke-width", 1.5);
        });
    } catch (error) {
        console.error("Error rendering the DAG:", error);
    }
}

    /**
     * Initialize visualization using provided query plan.
     */
    function initVisualization() {
        try {
            // Directly use the query plan from template context
            const queryPlan = {{ benchmark.query_plan | tojson }};

            if (!queryPlan || queryPlan.length === 0) {
                throw new Error("No query plan available.");
            }

            drawDag(queryPlan);
        } catch (error) {
            console.error("Failed to initialize query plan visualization:", error);
            alert("Unable to load query plan. Please check the console for more details.");
        }
    }

    /**
     * Get a node's color based on its type.
     */
    function getNodeColor(nodeType) {
        const colors = {
            "Source": "#2e8b57",
            "Sink": "#dc143c",
            "Selection": "#4682b4",
            "Filter": "#4682b4",
            "WindowedAggregation": "#ffa500",
            "EventTimeWatermarkAssigner": "#ba55d3",
            "Unknown": "#708090",
        };
        return colors[nodeType] || "#708090";
    }

    // Initialize visualization on page load
    document.addEventListener("DOMContentLoaded", initVisualization);
</script>
{% endblock %}