{% block head %}
<style>
    html, body {
        height: 100%;
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
    }

    body {
        display: flex;
        align-items: flex-start;
        justify-content: center;
        flex-direction: column;
    }

    #controls {
        margin: 1rem 0;
    }

    #svg-container {
        width: 100%;
        height: 600px;
        border: 1px solid #ccc;
        overflow: auto;
    }

    svg {
        width: 100%;
        height: 100%;
    }

    #raw-plan {
        max-height: 200px;
        overflow-y: auto;
        font-size: 12px;
    }
</style>
{% endblock %}

{% block content %}
<ul class="list-group mb-4">
    <li class="list-group-item list-group-item-primary">
        Raw Query Plan:
        <pre id="raw-plan">Loading query plan...</pre>
    </li>
</ul>

<div id="controls">
    <label for="plan-select">Choose a plan:</label>
    <select id="plan-select">
        <option>Loading plans...</option>
    </select>
</div>

<div id="svg-container">
    <svg id="svg"></svg>
</div>
{% endblock %}

{% block scripts %}
<script type="module">
    import * as d3 from "https://cdn.skypack.dev/d3@7.8.4";
    import * as d3dag from "https://cdn.skypack.dev/d3-dag@1.1.0";

    /**
     * Draws the Directed Acyclic Graph (DAG) for a specific query plan.
     * @param {Array} planData - The data for the query plan.
     */
    function drawDag(planData) {
        try {
            if (!Array.isArray(planData) || planData.length === 0) {
                console.error("Invalid plan data provided:", planData);
                return;
            }

            // Format DAG nodes
            const dagNodes = planData.map(node => ({
                id: node.id.toString(),
                parentIds: (node.inputs || []).map(input => input.toString()),
                label: node.label || "Unnamed",
                type: node.node_type || "Unknown",
            }));

            if (!dagNodes.every(node => node.id)) {
                console.error("Invalid DAG node data:", dagNodes);
                return;
            }

            // Clear existing SVG
            const svg = d3.select("#svg");
            svg.selectAll("*").remove();

            // Build the DAG
            const stratify = d3dag.graphStratify()
                .id(d => d.id)
                .parentIds(d => d.parentIds);
            const graph = stratify(dagNodes);

            // Layout configuration
            const layout = d3dag.sugiyama()
                .nodeSize([20, 10]) // Node width and height
                .coord(d3dag.coordCenter()); // Use center coordinates
            const { width, height } = layout(graph);

            const svgContainer = svg
                .attr("viewBox", `0 0 ${width + 100} ${height + 100}`)
                .attr("preserveAspectRatio", "xMidYMid meet");

            const container = svgContainer.append("g").attr("transform", "translate(50,50)");

            // Define link paths
            const line = d3.line().curve(d3.curveMonotoneY);
            container.append("g")
                .selectAll("path")
                .data(graph.links())
                .join("path")
                .attr("d", d => line(d.points))
                .attr("fill", "none")
                .attr("stroke", "#ccc")
                .attr("stroke-width", 2);

            // Define nodes
            const nodes = container.append("g")
                .selectAll("g")
                .data(graph.nodes())
                .join("g")
                .attr("transform", d => `translate(${d.x},${d.y})`);

            nodes.append("circle")
                .attr("r", 40)
                .attr("fill", d => getNodeColor(d.data.type));

            nodes.append("text")
                .text(d => d.data.label)
                .attr("text-anchor", "middle")
                .attr("dy", 4)
                .attr("fill", "white")
                .attr("font-size", 12);

        } catch (error) {
            console.error("Error drawing DAG:", error);
        }
    }

    /**
     * Fetches and populates selectable plans within the dropdown.
     * @param {Array} plans - Array of available benchmark plans.
     */
    function populatePlanSelector(plans) {
        const selector = document.getElementById("plan-select");
        selector.innerHTML = ""; // Clear existing options

        plans.forEach((plan, index) => {
            const option = document.createElement("option");
            option.value = index;
            option.textContent = plan.name || `Plan ${index + 1}`;
            selector.appendChild(option);
        });

        // Handle plan selection
        selector.addEventListener("change", () => {
            const selectedIndex = parseInt(selector.value, 10);
            const selectedPlan = plans[selectedIndex].query_plan;
            drawDag(selectedPlan);
            document.getElementById("raw-plan").textContent = JSON.stringify(selectedPlan, null, 2);
        });

        // Render the first plan by default
        if (plans.length > 0) {
            drawDag(plans[0].query_plan);
            document.getElementById("raw-plan").textContent = JSON.stringify(plans[0].query_plan, null, 2);
        }
    }

    /**
     * Loads plans and initializes the application.
     */
    async function init() {
        try {
            const response = await fetch(`/api/benchmarks/`);
            if (!response.ok) throw new Error(`Failed to fetch plans: ${response.status}`);

            const data = await response.json();
            const plans = data.results.map(benchmark => {
                return {
                    name: benchmark.tags?.name,
                    query_plan: benchmark.query_plan[0][1], // Extract desired plan
                };
            });

            populatePlanSelector(plans);
        } catch (error) {
            console.error("Error initializing the application:", error);
        }
    }

    /**
     * Get color for the node based on its type.
     * @param {String} nodeType - Data node type.
     * @returns {String} Color hex value.
     */
    function getNodeColor(nodeType) {
        const colors = {
            "Source": "#2e8b57",
            "Sink": "#dc143c",
            "Selection": "#4682b4",
            "Filter": "#4682b4", // Alias
            "WindowedAggregation": "#ffa500",
            "EventTimeWatermarkAssigner": "#ba55d3",
            "Unknown": "#708090",
        };
        return colors[nodeType] || "#708090"; // Default color
    }

    // Initialize on page load
    document.addEventListener("DOMContentLoaded", init);
</script>
{% endblock %}