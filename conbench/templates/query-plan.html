{% block head %}
    <style>
    .tree {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 30px;
        padding: 20px;
    }

    .tree-row {
        display: flex;
        gap: 40px;
        justify-content: center;
    }

    .pipeline, .logical-node {
        border: 2px dashed #aaa;
        padding: 10px;
        border-radius: 10px;
        background-color: #f0f0f0;
        min-width: 200px;
        max-width: 520px;
        word-wrap: break-word;
    }

    .pipeline-label, .logical-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: bold;
        margin-bottom: 10px;
        font-size: 16px;
    }

    .pipeline-tuples {
        font-size: 12px;
        color: #666;
        font-weight: normal;
    }

    .operators {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .operator {
        background-color: #d0e1f9;
        padding: 5px;
        border-radius: 6px;
        font-size: 14px;
        border: 1px solid #888;
    }

    .logical-label, .logical-node-type {
        background-color: #d0e1f9;
        padding: 5px;
        border-radius: 6px;
        font-size: 12px;
        border: 1px solid #888;
        white-space: pre-wrap;
        word-break: break-word;
        width: 100%;
    }

    .logical-label {
        margin-top: 4px;
    }
    </style>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/leader-line@1.0.7/leader-line.min.js"></script>
<script type="module">
    const pipelinePlan  = {{ benchmark.pipeline_query_plan | default('[]') | tojson }};
    const logicalPlan   = {{ benchmark.logical_query_plan  | default('[]') | tojson }};

    // tree origin, located in benchmark-result.html
    const treeContainer = document.getElementById('tree-container');

    // lines list saves all currently drawn lines
    // so we can delete them using the clearTree function
    // also removes the displayed query plan
    let lines = [];
    function clearTree() {
        treeContainer.innerHTML = '';
        lines.forEach(l => l.remove());
        lines = [];
    }

    function renderPipelinePlan() {
        clearTree();
        if(!pipelinePlan || !pipelinePlan.length) return;

        // creates the tree from bottom up
        // assigns levels to each pipeline to form the tree
        const sink = pipelinePlan.find(p => p.successors.length === 0);
        const levelsMap = new Map();
        const pipelineMap = new Map(pipelinePlan.map(p => [p.pipeline_id, p]));

        // recursively creates the levelsMap which assigns each pipelineId to a level
        function assignLevelsBottomUp(pid, level = 0) {
            if (levelsMap.has(pid) && levelsMap.get(pid) <= level) return;
            levelsMap.set(pid, level);
            const pipeline = pipelineMap.get(pid);
            pipeline.predecessors?.forEach(pred => assignLevelsBottomUp(pred, level + 1));
        }

        // start with the sink
        assignLevelsBottomUp(sink.pipeline_id);

        // creates 2D array: levels which contains all pipelines at the correct level
        const maxLevel = Math.max(...levelsMap.values());
        const levels = Array.from({ length: maxLevel + 1 }, () => []);
        pipelinePlan.forEach(p => {
            const level = levelsMap.get(p.pipeline_id);
            if (level !== undefined) levels[level].push(p);
        });

        // creates the html elements for each column and row in levels
        // also sorts and adds the operators
        // reversing puts the sources at the top and the sink to the bottom
        levels.reverse().forEach(row => {
            // create a row for each level
            const rowDiv = document.createElement('div');
            rowDiv.className = 'tree-row';

            // for each column in each row/ level create pipeline container
            row.forEach(pipeline => {
                // pipeline container
                const pipelineDiv = document.createElement('div');
                pipelineDiv.className = 'pipeline';
                pipelineDiv.id = `pipeline-${pipeline.pipeline_id}`;

                // TODO: same as in the logical plan, label should be renamed to avoid confusion
                // pipeline label which contains the id and incoming tuples
                // also put &nbsp between so they don't touch in case
                // the pipeline is thin or the number is huge
                const label = document.createElement('div');
                label.className = 'pipeline-label';
                label.innerHTML = `
                    <span class="pipeline-id">Pipeline ${pipeline.pipeline_id}</span>
                                        <span>&nbsp;&nbsp;&nbsp;</span>
                    <span class="pipeline-tuples">${pipeline.incoming_tuples.toLocaleString()} tuples</span>
                `;
                pipelineDiv.appendChild(label);

                // since the operators in the pipeline plan are not ordered,
                // they need to be sorted first
                // operator nodes can have at max one parent and child
                function sortOperators(operators){
                    const result = [];
                    if(operators.length === 0) return result;
                    // add start node
                    let node = operators.find(o => o.inputs.length === 0);
                    result.push(node);
                    // add all other nodes
                    while(node.outputs.length > 0){
                        if(node.inputs.length > 1 || node.outputs.length > 1) console.warn("WARNING MORE THAN 1 PARENT OR CHILD IN OPERATOR.");
                        node = operators.find(o => o.id === node.outputs[0]);
                        result.push(node);
                    }
                    return result;
                }

                // operator container
                const opsContainer = document.createElement('div');
                opsContainer.className = 'operators';
                const sortedOperators = sortOperators(pipeline.operators);
                sortedOperators.forEach(op => {
                    const opDiv = document.createElement('div');
                    opDiv.className = 'operator';
                    opDiv.textContent = `#${op.id}: ${op.label}`;
                    opsContainer.appendChild(opDiv);
                });

                // add divs to row
                pipelineDiv.appendChild(opsContainer);
                rowDiv.appendChild(pipelineDiv);
            });

            // add row to tree
            treeContainer.appendChild(rowDiv);
        });

        // draws arrows between pipelines and adds them to lines list for easy removal
        window.requestAnimationFrame(() => {
            pipelinePlan.forEach(p => {
                const from = document.getElementById(`pipeline-${p.pipeline_id}`);
                if (!from || !p.successors) return;

                // line for each successor
                p.successors.forEach(succId => {
                    const to = document.getElementById(`pipeline-${succId}`);
                    if (to) {
                        const line = drawLine(from, to);
                        lines.push(line);
                    }
                });
            });
        });
    }

    function renderLogicalPlan() {
        clearTree();
        if(!logicalPlan || !logicalPlan.length) return;

        // creates the tree from bottom up
        // assigns levels to each logical node to form the tree
        const sink = logicalPlan.find(node => node.outputs.length === 0);
        const nodeMap = new Map(logicalPlan.map(n => [n.id, n]));
        const levelsMap = new Map();

        // recursively creates the levelsMap which assigns each logical node id to a level
        function assignLevelBottomUp(id, level = 0) {
            if (levelsMap.has(id) && levelsMap.get(id) <= level) return;
            levelsMap.set(id, level);
            const node = nodeMap.get(id);
            node.inputs?.forEach(inputId => assignLevelBottomUp(inputId, level + 1));
        }

        // start with sink
        assignLevelBottomUp(sink.id)

        // creates 2D array: levels which contains all logical nodes at the correct level
        const max = Math.max(...levelsMap.values());
        const levels = Array.from({ length: max + 1 }, () => []);
        logicalPlan.forEach(n => {
            const level = levelsMap.get(n.id);
            if (level !== undefined) levels[level].push(n);
        });

        // creates the html elements for each column and row in levels
        // reversing puts the sources at the top and the sink to the bottom
        levels.reverse().forEach(row => {
            // create a row for each level
            const rowDiv = document.createElement('div');
            rowDiv.className = 'tree-row';

            // for each column in each row/ level create a node container
            row.forEach(node => {
                const div = document.createElement('div');
                div.className = 'logical-node';
                div.id = `logical-${node.id}`;

                // label/ headline of node consisting of node type and id
                // TODO: should be renamed, as label is an actual attribute of the node which is misleading
                const label = document.createElement('div');
                label.className = 'pipeline-label';
                label.innerHTML = `
                    <span class="pipeline-id">${node.node_type} ${node.id}</span>
                `;

                // add headline to container
                div.appendChild(label);

                // actual node label
                const lab = document.createElement('div');
                lab.className = 'operator';
                lab.textContent = node.label;

                // add node label to container
                div.appendChild(lab);
                // add container to row
                rowDiv.appendChild(div);
            });
            // add row to tree
            treeContainer.appendChild(rowDiv);
        });

        // draws arrows between logical nodes and adds them to lines list for easy removal
        window.requestAnimationFrame(() => {
            logicalPlan.forEach(n => {
                const from = document.getElementById(`logical-${n.id}`);
                n.outputs?.forEach(outId => {
                    const to = document.getElementById(`logical-${outId}`);
                    if (from && to) {
                        const line = drawLine(from, to);
                        lines.push(line);
                    }
                });
            });
        });
    }

    // creates and returns a line
    function drawLine(from, to){
        return new LeaderLine(from, to, {
            color: '#999',
            path: 'straight',
            startPlug: 'behind',
            endPlug: 'arrow3',
            endPlugSize: 1.2,
            size: 2,
            dropShadow: false,
            startSocket: 'bottom',
            endSocket: 'auto'
        });
    }

    // button logic for switching between pipeline and logical plan view
    // 'toggle-view' element is in benchmark-result.html
    const toggleButton = document.getElementById('toggle-view');
    let currentView = 'pipeline';
    toggleButton.addEventListener('click', () => {
        if (currentView === 'pipeline') {
            currentView = 'logical';
            toggleButton.textContent = 'Switch to Pipeline Plan';
            renderLogicalPlan();
        } else {
            currentView = 'pipeline';
            toggleButton.textContent = 'Switch to Logical Plan';
            renderPipelinePlan();
        }
    });

    // start with pipeline plan
    renderPipelinePlan();
</script>
{% endblock %}
